//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, CancelToken, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import { ClientBase } from './ClientBase';
import dayjs from 'dayjs'

export interface IFilesClient {
    uploadSingleFile(file?: FileParameter | null | undefined): Promise<ResultOfString>;
    uploadManyFiles(myFiles?: FileParameter[] | null | undefined): Promise<ResultOfStringOf>;
}

export class FilesClient extends ClientBase implements IFilesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    uploadSingleFile(file?: FileParameter | null | undefined, cancelToken?: CancelToken): Promise<ResultOfString> {
        let url_ = this.baseUrl + "/api/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUploadSingleFile(_response));
        });
    }

    protected processUploadSingleFile(response: AxiosResponse): Promise<ResultOfString> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfString.fromJS(resultData200);
            return Promise.resolve<ResultOfString>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfString>(null as any);
    }

    uploadManyFiles(myFiles?: FileParameter[] | null | undefined, cancelToken?: CancelToken): Promise<ResultOfStringOf> {
        let url_ = this.baseUrl + "/api/upload_many";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (myFiles !== null && myFiles !== undefined)
            myFiles.forEach(item_ => content_.append("myFiles", item_.data, item_.fileName ?? "test"));

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processUploadManyFiles(_response));
        });
    }

    protected processUploadManyFiles(response: AxiosResponse): Promise<ResultOfStringOf> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfStringOf.fromJS(resultData200);
            return Promise.resolve<ResultOfStringOf>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfStringOf>(null as any);
    }
}

export interface IEventsClient {
    postApiEventsModuleInitialize(): Promise<void>;
    deleteApiEventsCancel(id: string): Promise<void>;
    getEvent(id: string): Promise<ResultOfEventResponse>;
    getEvents(): Promise<ResultOfIReadOnlyCollectionOfEventResponse>;
    putApiEventsPublish(id: string): Promise<void>;
    putApiEventsReschedule(id: string, request: Request): Promise<void>;
}

export class EventsClient extends ClientBase implements IEventsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiEventsModuleInitialize( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/eventsModule/initialize";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiEventsModuleInitialize(_response));
        });
    }

    protected processPostApiEventsModuleInitialize(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteApiEventsCancel(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/events/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteApiEventsCancel(_response));
        });
    }

    protected processDeleteApiEventsCancel(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getEvent(id: string, cancelToken?: CancelToken): Promise<ResultOfEventResponse> {
        let url_ = this.baseUrl + "/api/events/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetEvent(_response));
        });
    }

    protected processGetEvent(response: AxiosResponse): Promise<ResultOfEventResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfEventResponse.fromJS(resultData200);
            return Promise.resolve<ResultOfEventResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfEventResponse>(null as any);
    }

    getEvents( cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfEventResponse> {
        let url_ = this.baseUrl + "/api/events";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetEvents(_response));
        });
    }

    protected processGetEvents(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfEventResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfEventResponse.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfEventResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfEventResponse>(null as any);
    }

    putApiEventsPublish(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/events/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiEventsPublish(_response));
        });
    }

    protected processPutApiEventsPublish(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    putApiEventsReschedule(id: string, request: Request, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/events/{id}/reschedule";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiEventsReschedule(_response));
        });
    }

    protected processPutApiEventsReschedule(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IVenuesClient {
    postApiVenues(request: CreateVenueRequest): Promise<ResultOfGuid>;
    getVenues(): Promise<ResultOfIReadOnlyCollectionOfVenueDto>;
    getVenue(id: string): Promise<ResultOfVenueDto>;
}

export class VenuesClient extends ClientBase implements IVenuesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiVenues(request: CreateVenueRequest, cancelToken?: CancelToken): Promise<ResultOfGuid> {
        let url_ = this.baseUrl + "/api/venues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiVenues(_response));
        });
    }

    protected processPostApiVenues(response: AxiosResponse): Promise<ResultOfGuid> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfGuid.fromJS(resultData200);
            return Promise.resolve<ResultOfGuid>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfGuid>(null as any);
    }

    getVenues( cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfVenueDto> {
        let url_ = this.baseUrl + "/api/venues";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetVenues(_response));
        });
    }

    protected processGetVenues(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfVenueDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfVenueDto.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfVenueDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfVenueDto>(null as any);
    }

    getVenue(id: string, cancelToken?: CancelToken): Promise<ResultOfVenueDto> {
        let url_ = this.baseUrl + "/api/venues/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetVenue(_response));
        });
    }

    protected processGetVenue(response: AxiosResponse): Promise<ResultOfVenueDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfVenueDto.fromJS(resultData200);
            return Promise.resolve<ResultOfVenueDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfVenueDto>(null as any);
    }
}

export interface ITicketTypesClient {
    postApiTicketTypes(request: CreateTicketTypeRequest): Promise<void>;
    getApiTicketTypes(): Promise<void>;
    getApiTicketTypes2(id: string): Promise<void>;
    putApiTicketTypes(id: string, request: UpdateTicketTypePriceRequest): Promise<void>;
}

export class TicketTypesClient extends ClientBase implements ITicketTypesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiTicketTypes(request: CreateTicketTypeRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/ticket-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiTicketTypes(_response));
        });
    }

    protected processPostApiTicketTypes(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getApiTicketTypes( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/ticket-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetApiTicketTypes(_response));
        });
    }

    protected processGetApiTicketTypes(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getApiTicketTypes2(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/ticket-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetApiTicketTypes2(_response));
        });
    }

    protected processGetApiTicketTypes2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    putApiTicketTypes(id: string, request: UpdateTicketTypePriceRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/ticket-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiTicketTypes(_response));
        });
    }

    protected processPutApiTicketTypes(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ISpeakersClient {
    postApiSpeakers(request: CreateSpeakerRequest): Promise<ResultOfGuid>;
    getSpeakersForEvent(id: string): Promise<ResultOfIReadOnlyCollectionOfSpeakerDto>;
    getSpeaker(id: string): Promise<ResultOfSpeakerDto>;
}

export class SpeakersClient extends ClientBase implements ISpeakersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiSpeakers(request: CreateSpeakerRequest, cancelToken?: CancelToken): Promise<ResultOfGuid> {
        let url_ = this.baseUrl + "/api/speakers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiSpeakers(_response));
        });
    }

    protected processPostApiSpeakers(response: AxiosResponse): Promise<ResultOfGuid> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfGuid.fromJS(resultData200);
            return Promise.resolve<ResultOfGuid>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfGuid>(null as any);
    }

    getSpeakersForEvent(id: string, cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfSpeakerDto> {
        let url_ = this.baseUrl + "/api/events/{id}/speakers";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetSpeakersForEvent(_response));
        });
    }

    protected processGetSpeakersForEvent(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfSpeakerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfSpeakerDto.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfSpeakerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfSpeakerDto>(null as any);
    }

    getSpeaker(id: string, cancelToken?: CancelToken): Promise<ResultOfSpeakerDto> {
        let url_ = this.baseUrl + "/api/speakers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetSpeaker(_response));
        });
    }

    protected processGetSpeaker(response: AxiosResponse): Promise<ResultOfSpeakerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfSpeakerDto.fromJS(resultData200);
            return Promise.resolve<ResultOfSpeakerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfSpeakerDto>(null as any);
    }
}

export interface IOrganizersClient {
    postApiOrganizerEvents(id: string, request: CreateEventRequest): Promise<ResultOfGuid>;
    getEventsForOrganizer(organizerId: string): Promise<ResultOfIReadOnlyCollectionOfEventResponse>;
    getVenuesForOrganizer(organizerId: string): Promise<ResultOfIReadOnlyCollectionOfVenueGridDto>;
    changeOrganizerStatus(id: string): Promise<ResultOfOrganizerDto>;
    createOrganizer(request: CreateOrganizerRequest): Promise<ResultOfGuid>;
    getOrganizers(): Promise<ResultOfIReadOnlyCollectionOfOrganizerDto>;
    getModerators(organizerId: string): Promise<ResultOfIReadOnlyCollectionOfModeratorDto>;
    getOrganizer(id: string): Promise<ResultOfOrganizerDto>;
}

export class OrganizersClient extends ClientBase implements IOrganizersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiOrganizerEvents(id: string, request: CreateEventRequest, cancelToken?: CancelToken): Promise<ResultOfGuid> {
        let url_ = this.baseUrl + "/api/organizer/{id}/events";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiOrganizerEvents(_response));
        });
    }

    protected processPostApiOrganizerEvents(response: AxiosResponse): Promise<ResultOfGuid> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfGuid.fromJS(resultData200);
            return Promise.resolve<ResultOfGuid>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfGuid>(null as any);
    }

    getEventsForOrganizer(organizerId: string, cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfEventResponse> {
        let url_ = this.baseUrl + "/api/organizers/{organizerId}/events";
        if (organizerId === undefined || organizerId === null)
            throw new Error("The parameter 'organizerId' must be defined.");
        url_ = url_.replace("{organizerId}", encodeURIComponent("" + organizerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetEventsForOrganizer(_response));
        });
    }

    protected processGetEventsForOrganizer(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfEventResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfEventResponse.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfEventResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfEventResponse>(null as any);
    }

    getVenuesForOrganizer(organizerId: string, cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfVenueGridDto> {
        let url_ = this.baseUrl + "/api/organizers/{organizerId}/venues";
        if (organizerId === undefined || organizerId === null)
            throw new Error("The parameter 'organizerId' must be defined.");
        url_ = url_.replace("{organizerId}", encodeURIComponent("" + organizerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetVenuesForOrganizer(_response));
        });
    }

    protected processGetVenuesForOrganizer(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfVenueGridDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfVenueGridDto.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfVenueGridDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfVenueGridDto>(null as any);
    }

    changeOrganizerStatus(id: string, cancelToken?: CancelToken): Promise<ResultOfOrganizerDto> {
        let url_ = this.baseUrl + "/api/organizers/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PATCH",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processChangeOrganizerStatus(_response));
        });
    }

    protected processChangeOrganizerStatus(response: AxiosResponse): Promise<ResultOfOrganizerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfOrganizerDto.fromJS(resultData200);
            return Promise.resolve<ResultOfOrganizerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfOrganizerDto>(null as any);
    }

    createOrganizer(request: CreateOrganizerRequest, cancelToken?: CancelToken): Promise<ResultOfGuid> {
        let url_ = this.baseUrl + "/api/organizers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processCreateOrganizer(_response));
        });
    }

    protected processCreateOrganizer(response: AxiosResponse): Promise<ResultOfGuid> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfGuid.fromJS(resultData200);
            return Promise.resolve<ResultOfGuid>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfGuid>(null as any);
    }

    getOrganizers( cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfOrganizerDto> {
        let url_ = this.baseUrl + "/api/organizers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetOrganizers(_response));
        });
    }

    protected processGetOrganizers(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfOrganizerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfOrganizerDto.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfOrganizerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfOrganizerDto>(null as any);
    }

    getModerators(organizerId: string, cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfModeratorDto> {
        let url_ = this.baseUrl + "/api/organizers/{organizerId}/moderators";
        if (organizerId === undefined || organizerId === null)
            throw new Error("The parameter 'organizerId' must be defined.");
        url_ = url_.replace("{organizerId}", encodeURIComponent("" + organizerId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetModerators(_response));
        });
    }

    protected processGetModerators(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfModeratorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfModeratorDto.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfModeratorDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfModeratorDto>(null as any);
    }

    getOrganizer(id: string, cancelToken?: CancelToken): Promise<ResultOfOrganizerDto> {
        let url_ = this.baseUrl + "/api/organizers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetOrganizer(_response));
        });
    }

    protected processGetOrganizer(response: AxiosResponse): Promise<ResultOfOrganizerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfOrganizerDto.fromJS(resultData200);
            return Promise.resolve<ResultOfOrganizerDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfOrganizerDto>(null as any);
    }
}

export interface ICategoriesClient {
    postApiCategories(request: CreateCategoryRequest): Promise<void>;
    getCategories(): Promise<ResultOfIReadOnlyCollectionOfCategoryDto>;
    getCategory(id: string): Promise<CategoryDto>;
    putApiCategories(id: string, request: UpdateCategoryRequest): Promise<void>;
}

export class CategoriesClient extends ClientBase implements ICategoriesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiCategories(request: CreateCategoryRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiCategories(_response));
        });
    }

    protected processPostApiCategories(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getCategories( cancelToken?: CancelToken): Promise<ResultOfIReadOnlyCollectionOfCategoryDto> {
        let url_ = this.baseUrl + "/api/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetCategories(_response));
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<ResultOfIReadOnlyCollectionOfCategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfIReadOnlyCollectionOfCategoryDto.fromJS(resultData200);
            return Promise.resolve<ResultOfIReadOnlyCollectionOfCategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfIReadOnlyCollectionOfCategoryDto>(null as any);
    }

    getCategory(id: string, cancelToken?: CancelToken): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetCategory(_response));
        });
    }

    protected processGetCategory(response: AxiosResponse): Promise<CategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryDto.fromJS(resultData200);
            return Promise.resolve<CategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(null as any);
    }

    putApiCategories(id: string, request: UpdateCategoryRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiCategories(_response));
        });
    }

    protected processPutApiCategories(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IUsersClient {
    postApiUsersModuleInitialize(): Promise<void>;
    getAuthTokens(request: GetAuthTokensRequest): Promise<ResultOfAuthTokenWithRefresh>;
    getApiUsersProfile(): Promise<void>;
    refreshToken(request: RefreshTokenRequest): Promise<ResultOfAuthTokenWithRefresh>;
    postApiUsersRegister(request: RegisterUserRequest): Promise<void>;
    putApiUsersProfile(id: string, request: UpdateUserProfileRequest): Promise<void>;
    getAuthTokensForOrganizer(request: GetAuthTokensRequest2): Promise<ResultOfAuthTokenWithRefresh>;
}

export class UsersClient extends ClientBase implements IUsersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    postApiUsersModuleInitialize( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/usersModule/initialize";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiUsersModuleInitialize(_response));
        });
    }

    protected processPostApiUsersModuleInitialize(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getAuthTokens(request: GetAuthTokensRequest, cancelToken?: CancelToken): Promise<ResultOfAuthTokenWithRefresh> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetAuthTokens(_response));
        });
    }

    protected processGetAuthTokens(response: AxiosResponse): Promise<ResultOfAuthTokenWithRefresh> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfAuthTokenWithRefresh.fromJS(resultData200);
            return Promise.resolve<ResultOfAuthTokenWithRefresh>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfAuthTokenWithRefresh>(null as any);
    }

    getApiUsersProfile( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/users/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetApiUsersProfile(_response));
        });
    }

    protected processGetApiUsersProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    refreshToken(request: RefreshTokenRequest, cancelToken?: CancelToken): Promise<ResultOfAuthTokenWithRefresh> {
        let url_ = this.baseUrl + "/api/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processRefreshToken(_response));
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<ResultOfAuthTokenWithRefresh> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfAuthTokenWithRefresh.fromJS(resultData200);
            return Promise.resolve<ResultOfAuthTokenWithRefresh>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfAuthTokenWithRefresh>(null as any);
    }

    postApiUsersRegister(request: RegisterUserRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPostApiUsersRegister(_response));
        });
    }

    protected processPostApiUsersRegister(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    putApiUsersProfile(id: string, request: UpdateUserProfileRequest, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/users/{id}/profile";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiUsersProfile(_response));
        });
    }

    protected processPutApiUsersProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getAuthTokensForOrganizer(request: GetAuthTokensRequest2, cancelToken?: CancelToken): Promise<ResultOfAuthTokenWithRefresh> {
        let url_ = this.baseUrl + "/api/auth/organizer/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetAuthTokensForOrganizer(_response));
        });
    }

    protected processGetAuthTokensForOrganizer(response: AxiosResponse): Promise<ResultOfAuthTokenWithRefresh> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultOfAuthTokenWithRefresh.fromJS(resultData200);
            return Promise.resolve<ResultOfAuthTokenWithRefresh>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultOfAuthTokenWithRefresh>(null as any);
    }
}

export interface ICartsClient {
    putApiCartsAdd(request: Request2): Promise<void>;
    deleteApiCarts(): Promise<void>;
    getApiCarts(): Promise<void>;
    putApiCartsRemove(request: Request3): Promise<void>;
}

export class CartsClient extends ClientBase implements ICartsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        super();

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? this.getBaseUrl("");

    }

    putApiCartsAdd(request: Request2, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiCartsAdd(_response));
        });
    }

    protected processPutApiCartsAdd(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    deleteApiCarts( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processDeleteApiCarts(_response));
        });
    }

    protected processDeleteApiCarts(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getApiCarts( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processGetApiCarts(_response));
        });
    }

    protected processGetApiCarts(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    putApiCartsRemove(request: Request3, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.instance.request(transformedOptions_);
        }).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.transformResult(url_, _response, (_response: AxiosResponse) => this.processPutApiCartsRemove(_response));
        });
    }

    protected processPutApiCartsRemove(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Result implements IResult {
    isSuccess!: boolean;
    isFailure!: boolean;
    error!: ErrorDto;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.isFailure = _data["isFailure"];
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["isFailure"] = this.isFailure;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResult {
    isSuccess: boolean;
    isFailure: boolean;
    error: ErrorDto;
}

export class ResultOfString extends Result implements IResultOfString {
    value!: string | undefined;

    constructor(data?: IResultOfString) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): ResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfString extends IResult {
    value: string | undefined;
}

export class ErrorDto implements IErrorDto {
    code!: string;
    description!: string;
    type!: ErrorType;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["type"] = this.type;
        return data;
    }
}

export interface IErrorDto {
    code: string;
    description: string;
    type: ErrorType;
}

export enum ErrorType {
    Failure = 0,
    Validation = 1,
    Problem = 2,
    NotFound = 3,
    Conflict = 4,
}

export class ResultOfStringOf extends Result implements IResultOfStringOf {
    value!: string[] | undefined;

    constructor(data?: IResultOfStringOf) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static override fromJS(data: any): ResultOfStringOf {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfStringOf();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfStringOf extends IResult {
    value: string[] | undefined;
}

export class ResultOfGuid extends Result implements IResultOfGuid {
    value!: string;

    constructor(data?: IResultOfGuid) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"];
        }
    }

    static override fromJS(data: any): ResultOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGuid();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfGuid extends IResult {
    value: string;
}

export class CreateVenueRequest implements ICreateVenueRequest {
    organizerId!: string;
    name!: string;
    description!: string;
    address!: AddressDto;
    imageContainers!: string[];

    constructor(data?: ICreateVenueRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizerId = _data["organizerId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["imageContainers"])) {
                this.imageContainers = [] as any;
                for (let item of _data["imageContainers"])
                    this.imageContainers!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateVenueRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateVenueRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizerId"] = this.organizerId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.imageContainers)) {
            data["imageContainers"] = [];
            for (let item of this.imageContainers)
                data["imageContainers"].push(item);
        }
        return data;
    }
}

export interface ICreateVenueRequest {
    organizerId: string;
    name: string;
    description: string;
    address: AddressDto;
    imageContainers: string[];
}

export class AddressDto implements IAddressDto {
    streetAndNumber!: string;
    city!: string;
    region!: string;
    country!: string;
    longitude!: number;
    latitude!: number;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.streetAndNumber = _data["streetAndNumber"];
            this.city = _data["city"];
            this.region = _data["region"];
            this.country = _data["country"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["streetAndNumber"] = this.streetAndNumber;
        data["city"] = this.city;
        data["region"] = this.region;
        data["country"] = this.country;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        return data;
    }
}

export interface IAddressDto {
    streetAndNumber: string;
    city: string;
    region: string;
    country: string;
    longitude: number;
    latitude: number;
}

export class ResultOfIReadOnlyCollectionOfVenueDto extends Result implements IResultOfIReadOnlyCollectionOfVenueDto {
    value!: VenueDto[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfVenueDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(VenueDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfVenueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfVenueDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfVenueDto extends IResult {
    value: VenueDto[] | undefined;
}

export class VenueDto implements IVenueDto {
    venueId!: string;
    name!: string;
    description!: string;
    address!: AddressDto;
    imageUrls!: string[];

    constructor(data?: IVenueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.venueId = _data["venueId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
            if (Array.isArray(_data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of _data["imageUrls"])
                    this.imageUrls!.push(item);
            }
        }
    }

    static fromJS(data: any): VenueDto {
        data = typeof data === 'object' ? data : {};
        let result = new VenueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["venueId"] = this.venueId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        return data;
    }
}

export interface IVenueDto {
    venueId: string;
    name: string;
    description: string;
    address: AddressDto;
    imageUrls: string[];
}

export class ResultOfVenueDto extends Result implements IResultOfVenueDto {
    value!: VenueDto | undefined;

    constructor(data?: IResultOfVenueDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? VenueDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultOfVenueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfVenueDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfVenueDto extends IResult {
    value: VenueDto | undefined;
}

export class CreateTicketTypeRequest implements ICreateTicketTypeRequest {
    eventId!: string;
    name!: string;
    price!: number;
    currency!: string;
    quantity!: number;

    constructor(data?: ICreateTicketTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.currency = _data["currency"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateTicketTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["name"] = this.name;
        data["price"] = this.price;
        data["currency"] = this.currency;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateTicketTypeRequest {
    eventId: string;
    name: string;
    price: number;
    currency: string;
    quantity: number;
}

export class UpdateTicketTypePriceRequest implements IUpdateTicketTypePriceRequest {
    price!: number;

    constructor(data?: IUpdateTicketTypePriceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): UpdateTicketTypePriceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTicketTypePriceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        return data;
    }
}

export interface IUpdateTicketTypePriceRequest {
    price: number;
}

export class CreateSpeakerRequest implements ICreateSpeakerRequest {
    name!: string;
    description!: string;
    links!: SpeakerLinkDto[];

    constructor(data?: ICreateSpeakerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(SpeakerLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateSpeakerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSpeakerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateSpeakerRequest {
    name: string;
    description: string;
    links: SpeakerLinkDto[];
}

export class SpeakerLinkDto implements ISpeakerLinkDto {
    url!: string;

    constructor(data?: ISpeakerLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): SpeakerLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpeakerLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface ISpeakerLinkDto {
    url: string;
}

export class ResultOfIReadOnlyCollectionOfSpeakerDto extends Result implements IResultOfIReadOnlyCollectionOfSpeakerDto {
    value!: SpeakerDto[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfSpeakerDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(SpeakerDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfSpeakerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfSpeakerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfSpeakerDto extends IResult {
    value: SpeakerDto[] | undefined;
}

export class SpeakerDto implements ISpeakerDto {
    id!: string;
    name!: string;
    description!: string;
    imageUrl!: string;
    links!: SpeakerLinkDto[];

    constructor(data?: ISpeakerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(SpeakerLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SpeakerDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpeakerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISpeakerDto {
    id: string;
    name: string;
    description: string;
    imageUrl: string;
    links: SpeakerLinkDto[];
}

export class ResultOfSpeakerDto extends Result implements IResultOfSpeakerDto {
    value!: SpeakerDto | undefined;

    constructor(data?: IResultOfSpeakerDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? SpeakerDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultOfSpeakerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfSpeakerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfSpeakerDto extends IResult {
    value: SpeakerDto | undefined;
}

export class CreateEventRequest implements ICreateEventRequest {
    categoryId!: string;
    title!: string;
    description!: string;
    venueId!: string;
    startsAtUtc!: dayjs.Dayjs;
    endsAtUtc!: dayjs.Dayjs | undefined;
    speakersIds!: string[];

    constructor(data?: ICreateEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.venueId = _data["venueId"];
            this.startsAtUtc = _data["startsAtUtc"] ? dayjs(_data["startsAtUtc"].toString()) : <any>undefined;
            this.endsAtUtc = _data["endsAtUtc"] ? dayjs(_data["endsAtUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["speakersIds"])) {
                this.speakersIds = [] as any;
                for (let item of _data["speakersIds"])
                    this.speakersIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["venueId"] = this.venueId;
        data["startsAtUtc"] = this.startsAtUtc ? this.startsAtUtc.toISOString() : <any>undefined;
        data["endsAtUtc"] = this.endsAtUtc ? this.endsAtUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.speakersIds)) {
            data["speakersIds"] = [];
            for (let item of this.speakersIds)
                data["speakersIds"].push(item);
        }
        return data;
    }
}

export interface ICreateEventRequest {
    categoryId: string;
    title: string;
    description: string;
    venueId: string;
    startsAtUtc: dayjs.Dayjs;
    endsAtUtc: dayjs.Dayjs | undefined;
    speakersIds: string[];
}

export class ResultOfIReadOnlyCollectionOfEventResponse extends Result implements IResultOfIReadOnlyCollectionOfEventResponse {
    value!: EventResponse[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfEventResponse) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(EventResponse.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfEventResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfEventResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfEventResponse extends IResult {
    value: EventResponse[] | undefined;
}

export class EventResponse implements IEventResponse {
    id!: string;
    categoryId!: string;
    title!: string;
    description!: string;
    startsAtUtc!: dayjs.Dayjs;
    endsAtUtc!: dayjs.Dayjs | undefined;
    ticketTypes!: TicketTypeResponse[];
    venue!: VenueDto;
    backgroundImage!: string;

    constructor(data?: IEventResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.categoryId = _data["categoryId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.startsAtUtc = _data["startsAtUtc"] ? dayjs(_data["startsAtUtc"].toString()) : <any>undefined;
            this.endsAtUtc = _data["endsAtUtc"] ? dayjs(_data["endsAtUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["ticketTypes"])) {
                this.ticketTypes = [] as any;
                for (let item of _data["ticketTypes"])
                    this.ticketTypes!.push(TicketTypeResponse.fromJS(item));
            }
            this.venue = _data["venue"] ? VenueDto.fromJS(_data["venue"]) : <any>undefined;
            this.backgroundImage = _data["backgroundImage"];
        }
    }

    static fromJS(data: any): EventResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["categoryId"] = this.categoryId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startsAtUtc"] = this.startsAtUtc ? this.startsAtUtc.toISOString() : <any>undefined;
        data["endsAtUtc"] = this.endsAtUtc ? this.endsAtUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.ticketTypes)) {
            data["ticketTypes"] = [];
            for (let item of this.ticketTypes)
                data["ticketTypes"].push(item.toJSON());
        }
        data["venue"] = this.venue ? this.venue.toJSON() : <any>undefined;
        data["backgroundImage"] = this.backgroundImage;
        return data;
    }
}

export interface IEventResponse {
    id: string;
    categoryId: string;
    title: string;
    description: string;
    startsAtUtc: dayjs.Dayjs;
    endsAtUtc: dayjs.Dayjs | undefined;
    ticketTypes: TicketTypeResponse[];
    venue: VenueDto;
    backgroundImage: string;
}

export class TicketTypeResponse implements ITicketTypeResponse {
    ticketTypeId!: string;
    name!: string;
    price!: number;
    currency!: string;
    quantity!: number;

    constructor(data?: ITicketTypeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketTypeId = _data["ticketTypeId"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.currency = _data["currency"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): TicketTypeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TicketTypeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketTypeId"] = this.ticketTypeId;
        data["name"] = this.name;
        data["price"] = this.price;
        data["currency"] = this.currency;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ITicketTypeResponse {
    ticketTypeId: string;
    name: string;
    price: number;
    currency: string;
    quantity: number;
}

export class ResultOfIReadOnlyCollectionOfVenueGridDto extends Result implements IResultOfIReadOnlyCollectionOfVenueGridDto {
    value!: VenueGridDto[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfVenueGridDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(VenueGridDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfVenueGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfVenueGridDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfVenueGridDto extends IResult {
    value: VenueGridDto[] | undefined;
}

export class VenueGridDto implements IVenueGridDto {
    venueId!: string;
    name!: string;
    description!: string;
    shortAddress!: string;

    constructor(data?: IVenueGridDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.venueId = _data["venueId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.shortAddress = _data["shortAddress"];
        }
    }

    static fromJS(data: any): VenueGridDto {
        data = typeof data === 'object' ? data : {};
        let result = new VenueGridDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["venueId"] = this.venueId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["shortAddress"] = this.shortAddress;
        return data;
    }
}

export interface IVenueGridDto {
    venueId: string;
    name: string;
    description: string;
    shortAddress: string;
}

export class ResultOfEventResponse extends Result implements IResultOfEventResponse {
    value!: EventResponse | undefined;

    constructor(data?: IResultOfEventResponse) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? EventResponse.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultOfEventResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfEventResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfEventResponse extends IResult {
    value: EventResponse | undefined;
}

export class Request implements IRequest {
    startsAtUtc!: dayjs.Dayjs;
    endsAtUtc!: dayjs.Dayjs | undefined;

    constructor(data?: IRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startsAtUtc = _data["startsAtUtc"] ? dayjs(_data["startsAtUtc"].toString()) : <any>undefined;
            this.endsAtUtc = _data["endsAtUtc"] ? dayjs(_data["endsAtUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startsAtUtc"] = this.startsAtUtc ? this.startsAtUtc.toISOString() : <any>undefined;
        data["endsAtUtc"] = this.endsAtUtc ? this.endsAtUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRequest {
    startsAtUtc: dayjs.Dayjs;
    endsAtUtc: dayjs.Dayjs | undefined;
}

export class CreateCategoryRequest implements ICreateCategoryRequest {
    name!: string;

    constructor(data?: ICreateCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateCategoryRequest {
    name: string;
}

export class ResultOfIReadOnlyCollectionOfCategoryDto extends Result implements IResultOfIReadOnlyCollectionOfCategoryDto {
    value!: CategoryDto[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfCategoryDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfCategoryDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfCategoryDto extends IResult {
    value: CategoryDto[] | undefined;
}

export class CategoryDto implements ICategoryDto {
    id!: string;
    name!: string;
    isArchived!: boolean;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isArchived = _data["isArchived"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isArchived"] = this.isArchived;
        return data;
    }
}

export interface ICategoryDto {
    id: string;
    name: string;
    isArchived: boolean;
}

export class UpdateCategoryRequest implements IUpdateCategoryRequest {
    name!: string;

    constructor(data?: IUpdateCategoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateCategoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateCategoryRequest {
    name: string;
}

export class ResultOfAuthTokenWithRefresh extends Result implements IResultOfAuthTokenWithRefresh {
    value!: AuthTokenWithRefresh | undefined;

    constructor(data?: IResultOfAuthTokenWithRefresh) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? AuthTokenWithRefresh.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultOfAuthTokenWithRefresh {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfAuthTokenWithRefresh();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfAuthTokenWithRefresh extends IResult {
    value: AuthTokenWithRefresh | undefined;
}

export class AuthTokenWithRefresh implements IAuthTokenWithRefresh {
    access_token!: string;
    refresh_token!: string;
    organizer_id!: string;

    constructor(data?: IAuthTokenWithRefresh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
            this.organizer_id = _data["organizer_id"];
        }
    }

    static fromJS(data: any): AuthTokenWithRefresh {
        data = typeof data === 'object' ? data : {};
        let result = new AuthTokenWithRefresh();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        data["organizer_id"] = this.organizer_id;
        return data;
    }
}

export interface IAuthTokenWithRefresh {
    access_token: string;
    refresh_token: string;
    organizer_id: string;
}

export class GetAuthTokensRequest implements IGetAuthTokensRequest {
    email!: string;
    password!: string;

    constructor(data?: IGetAuthTokensRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GetAuthTokensRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuthTokensRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IGetAuthTokensRequest {
    email: string;
    password: string;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

export class RegisterUserRequest implements IRegisterUserRequest {
    email!: string;
    password!: string;
    firstName!: string;
    lastName!: string;

    constructor(data?: IRegisterUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterUserRequest {
    email: string;
    password: string;
    firstName: string;
    lastName: string;
}

export class UpdateUserProfileRequest implements IUpdateUserProfileRequest {
    firstName!: string;
    lastName!: string;

    constructor(data?: IUpdateUserProfileRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UpdateUserProfileRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserProfileRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUpdateUserProfileRequest {
    firstName: string;
    lastName: string;
}

export class ResultOfOrganizerDto extends Result implements IResultOfOrganizerDto {
    value!: OrganizerDto | undefined;

    constructor(data?: IResultOfOrganizerDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.value = _data["value"] ? OrganizerDto.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ResultOfOrganizerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrganizerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfOrganizerDto extends IResult {
    value: OrganizerDto | undefined;
}

export class OrganizerDto implements IOrganizerDto {
    id!: string;
    name!: string;
    description!: string;

    constructor(data?: IOrganizerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): OrganizerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IOrganizerDto {
    id: string;
    name: string;
    description: string;
}

export class CreateOrganizerRequest implements ICreateOrganizerRequest {
    name!: string;
    description!: string;
    registerUserCommand!: RegisterUserCommand;

    constructor(data?: ICreateOrganizerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.registerUserCommand = _data["registerUserCommand"] ? RegisterUserCommand.fromJS(_data["registerUserCommand"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrganizerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["registerUserCommand"] = this.registerUserCommand ? this.registerUserCommand.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrganizerRequest {
    name: string;
    description: string;
    registerUserCommand: RegisterUserCommand;
}

export class RegisterUserCommand implements IRegisterUserCommand {
    email!: string;
    password!: string;
    firstName!: string;
    lastName!: string;

    constructor(data?: IRegisterUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IRegisterUserCommand {
    email: string;
    password: string;
    firstName: string;
    lastName: string;
}

export class ResultOfIReadOnlyCollectionOfOrganizerDto extends Result implements IResultOfIReadOnlyCollectionOfOrganizerDto {
    value!: OrganizerDto[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfOrganizerDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(OrganizerDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfOrganizerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfOrganizerDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfOrganizerDto extends IResult {
    value: OrganizerDto[] | undefined;
}

export class GetAuthTokensRequest2 implements IGetAuthTokensRequest2 {
    email!: string;
    password!: string;

    constructor(data?: IGetAuthTokensRequest2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GetAuthTokensRequest2 {
        data = typeof data === 'object' ? data : {};
        let result = new GetAuthTokensRequest2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IGetAuthTokensRequest2 {
    email: string;
    password: string;
}

export class ResultOfIReadOnlyCollectionOfModeratorDto extends Result implements IResultOfIReadOnlyCollectionOfModeratorDto {
    value!: ModeratorDto[] | undefined;

    constructor(data?: IResultOfIReadOnlyCollectionOfModeratorDto) {
        super(undefined);
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(ModeratorDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): ResultOfIReadOnlyCollectionOfModeratorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIReadOnlyCollectionOfModeratorDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIReadOnlyCollectionOfModeratorDto extends IResult {
    value: ModeratorDto[] | undefined;
}

export class ModeratorDto implements IModeratorDto {
    userId!: string;
    firstName!: string;
    lastName!: string;
    email!: string;
    isOwner!: boolean;
    isActive!: boolean;

    constructor(data?: IModeratorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.isOwner = _data["isOwner"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ModeratorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModeratorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["isOwner"] = this.isOwner;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IModeratorDto {
    userId: string;
    firstName: string;
    lastName: string;
    email: string;
    isOwner: boolean;
    isActive: boolean;
}

export class Request2 implements IRequest2 {
    ticketTypeId!: string;
    quantity!: number;

    constructor(data?: IRequest2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketTypeId = _data["ticketTypeId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): Request2 {
        data = typeof data === 'object' ? data : {};
        let result = new Request2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketTypeId"] = this.ticketTypeId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IRequest2 {
    ticketTypeId: string;
    quantity: number;
}

export class Request3 implements IRequest3 {
    ticketTypeId!: string;

    constructor(data?: IRequest3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketTypeId = _data["ticketTypeId"];
        }
    }

    static fromJS(data: any): Request3 {
        data = typeof data === 'object' ? data : {};
        let result = new Request3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketTypeId"] = this.ticketTypeId;
        return data;
    }
}

export interface IRequest3 {
    ticketTypeId: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new SwaggerException(message, status, response, headers, result);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
